# DataStructuresAndAlgorithms
自学数据结构与算法的笔记

# 笔记
## 使用教材：《大话数据结构》
## 使用语言：C语言（C90标准）
## 代码编写工具：Visual Studio Code
## 使用编译器：gcc8.1.0
## 一、数据结构以及算法的定义  
    1、程序设计 = 数据结构 + 算法。
    2、数据结构：指相互之间存在一种或多种特定关系的数据元素的集合。
    3、算法：解决特定问题求解步骤的描述。
    4、算法的五个基本特性：输入、输出、有穷性、确定性、可行性。
    5、算法可以有零个或多个输入，至少有一个输出。
    6、用大O记法来表示算法时间复杂度。
    7、推导大O阶：
        (1)用常数1取代运行时间中的所有加法常数。
        (2)在修改后的运行次数函数中，只保留最高阶项。
        (3)如果最高阶项存在且不是1，则去除与这个项相乘的常数。
        最终得到的结果就是大O阶。
    8、常用时间复杂度分类：
        (1)常数阶：O(1)
        (2)线性阶：O(n)
        (3)对数阶：O(logn)
        (4)平方阶：O(n²)
        (5)nlogn阶：O(nlogn)
        (6)立方阶：O(n³)
        (7)指数阶：O(2^n)
    9、常用时间复杂度按照耗费时间从小到大排序：
        O(1) < O(logn) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2^n) < O(n!) < O(n^n)
    10、一般情况下说的时间复杂度都是最坏情况下的时间复杂度。
    11、算法的设计要求：正确性、可读性、健壮性、高效率和低存储量需求。
    12、算法的度量方法：事后统计方法(不科学、不准确)、事前分析估算方法。
## 二、线性表
    1、线性表：零个或多个数据元素的有限序列。(序列表示线性表元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素有且只有一个前驱和后继。)
    数据类型定义：
        ADT 线性表(List)
        Data
            线性表的数据对象集合为{a1,a2,...，an}，每个元素的类型均为DataType。
            其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。
            数据元素之间的关系是一对一的关系。
        Operation
            InitList(*L)：初始化操作，建立一个空的线性表L。
            ListEmpty(L)：若线性表为空，返回true；否则返回false。
            ClearList(*L)：将线性表清空。
            GetElem(L, i, *e)：将线性表L中的第i个位置元素值返回给e。
            LocationElem(L, e)：在线性表L中查找与给定元素值e相等的元素，如果查找成功，返回该元素在表中序号表示成功。
        end ADT
    2、线性表的两种物理结构：
        (1)顺序存储结构：用一段地址连续的存储单元依次存储线性表的数据元素。
            (a)顺序线性表的结构代码：
                ```c
                    /*存储空间初始分配量*/
                    #define MAXSIZE 20
                    /*ElemType类型根据实际情况而定，这里假设为int*/
                    typedef int ElemType;
                    typedef struct {
                        /*数组存储数据元素，最大容量为MAXSIZE*/
                        ElemType data[MAXSIZE];
                        /*线性表当前长度*/
                        int length;
                    } SqList;
                ```
            注意：在任意时刻，线性表长度应该小于等于数组的长度。
            (b)顺序线性表元素位置的计算：
                假设线性表中每一个元素占用c个存储单元，那么第i+1个数据元素与第i个数据元素的存储位置关系：
                LOC(ai + 1) = LOC(ai) + c
                因此：对于第i个数据元素ai的存储位置可以有a1推出：
                LOC(ai) = LOC(a1) + (i - 1) * c
                通过这个公式，可以得出该线性表的存取数据的时间复杂度为O(1)，通常把具有这一特点的存储结构成为随机存取结构。  
            (c)顺序线性表获取元素(GetElem)的操作：
                ```c
                    #define OK 1
                    #define ERROR 0
                    #define TRUE 1
                    #define FALSE 0
                    /*Status是函数的类型，其值是函数结果状态代码，如OK等*/
                    typedef int Status;
                    /*初始条件：顺序线性表L已经存在，1 <= i <= ListLength(L)*/
                    /*操作结果：用e放回L中第i个数据元素的值*/
                    Status GetElem(SqList L, int i, ElemType *e) {
                        if (L.length == 0 || i < 1 || i > length) {
                            return ERROR;
                        }
                        *e = L.data[i - 1];
                        return OK;
                    }
                ```
            (d)顺序线性表的插入(ListInsert)操作：
                思路：
                    如果插入位置不合理，则抛出异常；
                    如果线性表长度大于等于数组长度，则抛出异常或者动态增加容量；
                    从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；
                    将要插入元素填入位置i处；线性表长度+1。
                实现代码：
                ```c
                    /*初始条件：顺序线性表L已存在,1 <= i <= ListLength(L)*/
                    /*操作结果：在L中第i个位置之前插入心得数据元素e，L的长度加1*/
                    Status ListLength(SqList *L, int i, ElemType e){
                        int k;
                        /*顺序线性表已满*/
                        if (L->length == MAXSIZE) {
                            return ERROR;
                        }
                        /*当i不在范围内时*/
                        if (i < 1 || i > L->length + 1) {
                            return ERROR;
                        }
                        /*若插入数据位置不在表尾*/
                        if (i <= L->length) {
                            /*将要插入位置后数据元素向后移动一位*/
                            for (k = L->length - 1; k >= i; k--) {
                                L->data[k + 1] = L->data[k];
                            }
                        }
                        /*将新元素插入*/
                            L->data[i - 1] = e;
                            L->length++;
                            return OK;
                    }
                ```
            (e)顺序线性表的删除(ListDelete)操作：
                思路：
                    如果删除位置不合理，抛出异常；
                    取出删除元素；
                    从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；
                    表长减一。
                实现代码：
                ```c
                    /*初始条件：顺序线性表L已存在,1 <= i <= ListLength(L)*/
                    /*操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1*/
                    Status ListDelete(SqList *L, int i, ElemType *e) {
                        int k;
                        /*线性表为空*/
                        if (L->length == 0) {
                            return ERROR;
                        }
                        /*删除位置不合理*/
                        if (i < 1 || i > L->length) {
                            return OK;
                        }
                        *e = L->data[i - 1];
                        /*如果删除的不是最后一个位置*/
                        if (i < L->length) {
                            /*将删除位置后继元素前移*/
                            for (k = i; k < L->length; k++) {
                                L->data[k - 1] = L->data[k];
                            }
                        }
                        L->length--;
                        return OK;
                    }
                ```
            (f)分析可得出，线性表的顺序存储结构在插入、删除操作时的时间复杂度为O(n)，说明它比较适合于元素个数不太变化，而更多的是存取数据的应用。
            (g)线性表顺序存储结构的优缺点：
                优点：
                    无须为表示表中元素之间的逻辑关系而增加额外的存储空间；
                    可以快速地存取表中任一位置的元素。
                缺点：
                    插入和删除操作需要移动大量元素；
                    当线性表长度变化较大时，难以确定存储空间的容量；
                    造成存储空间的“碎片”。
        (2)链式存储结构：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。为了表示ai与其直接后继元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。把存储数据元素信息的域成为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)。n个结点链结成一个链表，即为线性表的链式存储结构，只有一个指针域的称为单链表。
            (a)头指针与头结点的区别：
                头指针：
                    头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头节点的指针；
                    头指针具有标识作用，所以常用头指针冠以链表的名字；
                    无论链表是否为空，头指针均不为空。头指针是链表的必要元素。
                头结点：
                    头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义(也可以存放链表的长度);
                    有了头结点，对在第一元素结点前插入和删除第一结点，其操作与其它结点的操作就统一了；
                    头结点不一定是链表必须要素。
            (b)线性表的单链表存储结构代码描述：
            ```c
                /*线性表的单链表存储结构*/
                typedef struct Node {
                    ElemType data;
                    struct Node *next;
                } Node;
                /*定义LinkList*/
                typedef struct Node* LinkList;
            ```
            (c)单链表的读取：
                获取链表第i个数据的算法思路：
                    声明一个指针p指向链表第一个结点，初始化j从1开始；
                    当j < i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；
                    弱到链表末尾p为空，则说明第i个结点不存在；
                    若查找成功，返回结点p的数据。
                实现代码：
                ```c
                    /*初始条件：顺序线性表L已存在，1 <= i <= ListLength(L)*/
                    /*操作结果：用e返回L中第i个数据元素的值*/
                    Status GetElem(LinkList L, int i, ElemType *e) {
                        int j;
                        /*声明一个指针p*/
                        LinkList p;
                        /*让p指向链表L的第一个结点，因为假设L是带头结点的，所以L->next才是第一个结点*/
                        p = L->next;
                        /*j为计数器*/
                        j = 1;
                        /*p不为空且计数器j还没有等于i时，循环继续*/
                        while (p && j < i) {
                            p = p->next;
                            ++j;
                        }
                        /*第i个结点不存在*/
                        if (!p || j > i) {
                            return ERROR;
                        }
                        /*取第i个结点的数据*/
                        *e = p->data;
                        return OK;
                    }
                ```
                分析可得，单链表的读取时间复杂度为O(n)。
            (d)单链表的插入操作：
                思路：
                    声明一指针p指向链表头结点，初始化j从1开始；
                    当j < i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；
                    若到链表末尾p为空，则说明第i个结点不存在；
                    否则查找成功，在系统中生成一个空结点s；
                    讲数据元素e赋值给s->data；
                    单链表的插入标准语句:s->next = p->next;p->next = s;(这两句话绝对不能交换顺序);
                    返回成功。
                实现代码：
                ```c
                    /*初始条件：顺序线性表L已存在，1 <= i <= ListLength(L)*/
                    /*操作结果：在L中第i个结点位置之前插入新的数据元素e，L长度加1*/
                    Status ListInsert(LinkList *L, int i, ElemType e) {
                        int j;
                        LinkList p, s;
                        p = *L;
                        j = 1;
                        /*寻找第i - 1个结点*/
                        while (p && j < i) {
                            p = p->next;
                            ++j;
                        }
                        /*第i个结点不存在*/
                        if (!p || j > i) {
                            return ERROR;
                        }
                        /*生成新结点*/
                        s = (LinkList)malloc(sizeof(Node));
                        s->data = e;
                        s->next = p->next;
                        p->next = s;
                        return OK;
                    }
                ```
            (e)单链表的删除操作：
                思路：
                    声明一指针p指向链表头结点，初始化j从1开始；
                    当j < i时，就遍历链表，让p得指针向后移动，不断指向下一个结点，j累加1；
                    若到链表末尾p为空，则说明第i个结点不存在；
                    否则查找成功，将欲删除得结点p->next赋值给q；
                    单链表的删除标准语句p->next = 1->next;
                    将q结点中的数据赋值给e，作为返回；
                    释放q结点；
                    返回成功。
                实现代码：
                ```c
                    /*初始条件：顺序线性表L已存在，1 <= i <= ListLength(L)*/
                    /*操作结果：删除L的第i个结点，并用e返回其值，L的长度减1*/
                    Status ListDelete(LinkList *L, int i, ElemType e) {
                        int j;
                        LinkList p, q;
                        p = *L;
                        j = 1;
                        /*遍历寻找第i-1个结点*/
                        while (p->next && j < i) {
                            p = p->next;
                            ++j;
                        }
                        /*第i个结点不存在*/
                        if (!(p->next) || j > i) {
                            return ERROR;
                        }
                        q = p->next;
                        /*将q的后继赋值给p的后继*/
                        p->next = q->next;
                        /*将q结点中的数据给e*/
                        *e = q->data;
                        /*让系统回收此结点，释放内存*/
                        free(q);
                        return OK;
                    }
                ```
            (f)分析可以得出，单链表的插入与删除时间复杂的都也是O(n)，乍一看与顺序表没啥优势，但是如果当同时插入多个数据，那么单链表只有第一次需要遍历寻找第i个结点的位置，时间复杂度为O(n)，但是后面的几次就只需要简单的赋值移动指针完成了，时间复杂度为O(1)。所以，对于插入或删除数据越频繁的操作，单链表的效率优势就越明显。
            (g)单链表的整表创建：
                思路：
                    声明一指针p和计数变量i；
                    初始化一空链表L；
                    让L的头结点的指针指向NULL，即建立一个带头结点的单链表；
                    循环：
                        生成一新结点赋值给p；
                        随机生成一数字赋值给p的数据域p->data；
                        将p插入到头结点域前一新结点之间。
                实现代码：
                ```c
                    /*随机产生n个元素的值，建立带表头结点的线性单链表L(头插法)*/
                    void CreateListHead(LinkList *L, int n) {
                        LinkList p;
                        int i;
                        /*初始化随机数种子*/
                        srand(time(0));
                        *L = (LinkList)malloc(sizeof(Node));
                        /*先建立一个带头结点的单链表*/
                        (*L)->next = NULL;
                        for (i = 0; i < n; i++) {
                            /*生成新节点*/
                            p = (LinkList)malloc(sizeof(Node));
                            /*随机生成100以内的数字*/
                            P->data = rand() % 100 + 1;
                            p->next = (*L)->next;
                            /*插入到表头*/
                            (*L)->next = p;
                        }
                    }
                ```
                ```c
                    /*随机产生n个元素的值，建立带表头结点的线性单链表L(尾插法)*/
                    void CreateListTail(LinkList *L, int n) {
                        LinkList p, r;
                        int i;
                        /*初始化随机数种子*/
                        srand(time(0));
                        /*L指整个单链表*/
                        *L = (LinkList)malloc(sizeof(Node));
                        /*r为指向尾部的结点*/
                        r = *L;
                        for (i = 0; i < n; i++) {
                            /*生成新节点*/
                            p = (LinkList)malloc(sizeof(Node));
                            /*随机生成100以内的数字*/
                            P->data = rand() % 100 + 1;
                            /*将表尾终端结点的指针指向新结点*/
                            r->next = p;
                            /*将当前的新结点定义为表尾终端结点*/
                            r = p;
                        }
                        /*表示当前链表结束*/
                        r->next = NULL;
                    }
                ```
            (h)单链表的整表删除：
                思路：
                    声明一个指针p和q；
                    将第一个结点赋值给p；
                    循环：
                        将下一结点赋值给q；
                        释放p；
                        将q赋值给p。
                实现代码：
                ```c
                    /*初始条件：顺序线性表L已存在，操作结果：将L重置为空表*/
                    Status ClearList(LinkList *L) {
                        LinkList p, q;
                        /*p指向第一个结点*/
                        p = (*L)->next;
                        /*没到表尾*/
                        while (p) {
                            q = p->next;
                            free(p);
                            p = q;
                        }
                        /*将头结点的指针域设置为空*/
                        (*L)->next = NULL;
                        return OK;
                    }
                ```
        (3)单链表结构与顺序存储结构的对比：
            (a)存储分配方式：
                顺序存储结构用一段连续的存储单元依次存储线性表的数据元素；
                单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。
            (b)时间性能：
                查找：
                    顺序存储结构O(1)；
                    单链表O(n)。
                插入和删除：
                    顺序存储结构需要平均移动表长一半的元素，时间为O(n)；
                    单链表在找出某位置的指针后，插入和删除时间仅为O(1)。
            (c)空间性能：
                顺序存储结构徐涛预分配存储空间，分大了，浪费，分小了易发生上溢；
                单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。
            通过上面的对比，可以得出一些经验性的总结：
                若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构；
                当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，如果事先知道线性表的大致长度，用顺序存储结构效率会高很多。
    3、静态链表：使用数组来代替指针，来描述单链表。首席按，让数组的元素都是由两个数据域组成，data和cur。也就是说，数组的每一个下表都对应一个data和一个cur。数据域data用来存放数据元素；而游标cur相当于单链表中的next指针，存放该元素的后继在数组中的下标。就把这种用数组表述的链表叫静态链表，还有起名叫做游标实现法。主要用于不支持指针的程序设计语言中。
    4、线性表的静态链表的存储结构：
    ```c
        /*线性表的静态链表存储结构*/
        /*假设链表的最大长度为1000*/
        #define MAXSIZE 1000
        typedef struct {
            ElemType data;
            /*游标，为0时表示无指向*/
            int cur;
        } Component, StaticLinkList[MAXSIZE];
    ```
    另外对数组第一个和最后一个元素作为特殊元素处理，不存数据。
    通常把未被使用的数组元素称为备用链表。
    数组第一个元素，即下标为0的元素cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值元素的下标，相当于单链表中的头结点作用,当整个链表为空时，则为0。
    初始化的数组状态：
    ```c
        /*将一维数组space中各分量链成一备用链表*/
        /*space[0].cur*为头指针，"0"表示空指针*/
        Status InitList(StaticLinkList space) {
            int i;
            for (i = 0; i < MAXSIZE - 1; i++) {
                space[i].cur = i + 1;
            }
            /*目前静态链表为空，最后一个元素的cur为0*/
            space[MAXSIZE - 1].cur = 0;
            return OK;
        }
    ```
## 三、
        